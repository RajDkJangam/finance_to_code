------------------ Dynamic vs. Lexical Scope -----------------

Javascript is by nature a "write-time" scope (lexical), whereas other languages may run with "run-time" scope (dynamic).  In order to execute "run-time" scope, you must use the "this" keyword in javascript. 

See the example below: 

function foo() {
    console.log( a ); // 3  (not 2!)
}

function bar() {
    var a = 3;
    foo();
}

var a = 2;

bar();

In dynamic scoping, this would return a value of "3," because after failing to find the value of "a" when foo() is executed, it is going to look for the scope in which foo() was called from, which is bar().  In the scope of bar(), var a = 3, not 2.

In javascript, this does not work, because it is a lexically scoped language.


------------------- Dynamic Scope with "this" keyword ---------

To learn "this", you first have to learn what "this" is not, despite any assumptions or misconceptions that may lead you down those paths. 

"this" is neither a reference to the function itself, nor is it a reference to the function's lexical scope.  

"this" is actually a binding that is made when a function is invoked, and what it references is determined entirely by the call-site where the function is called.


There are four methods of using "this" : 

-----------  1. Default - 

    function fun(){
        console.log(this.number);
    }

    var number = 2;

    fun(); // 2

    // Here, the function containing "this" is called in the global scope, which means that "this" refers to the global scope.


----------  2. Implicit 

    function fun(){
        console.log(this.number);
    }

    var obj = {
        number: 2,
        fun: fun
    };

    var number = 4;

    obj.fun(); //2

    // Now, the function's call site is within the scope of "obj," so "this" refers to "obj", and returns 2 rather than 4.

------------  3. Explicit 

    function fun(){
        console.log(this.number);
    }

    var obj = {
        number: 2,
        fun: fun
    }

    var number = 4; 

    fun.call(obj); //2 

    // Another way of getting the same result as in the implicit example is to use explicit binding to tell the engine exactly what you want "this" to refer to.  Here, we are telling it that we want "this" to represent "obj", so "this.number" returns 2 rather than 4.

------------ 4. New binding 

function foo(a) {
    this.a = a;
}

var bar = new foo( 2 );
console.log( bar.a ); // 2

Here, we have used "new" to set foo() as a new object that is the object equal to "this."

While self = this and arrow-functions both seem like good "solutions" to not wanting to use bind(..), they are essentially fleeing from this instead of understanding and embracing it.

------------------ Objects ----------------------------------

In javascript, there are built in objects.  There are also "complex primitives," which are object subtypes that can behave like objects.  A function is an example of a "complex primitive."  