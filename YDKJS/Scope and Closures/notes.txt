Block scoping: putting variables as close as possible to the location of use 

ex: for(var i = 0; i>10; i++){};

Another useful block-scoping mechanism: 

 catch (err) {
    console.log( err ); // works!
}

let a = 2;
const a = 2;

Both of the above are methods of creating blocked scope, but the second keeps the value of a constant, while the first allows for changes later in the code.

"Though some seem to believe so, block scope should not be taken as an outright replacement of var function scope. Both functionalities co-exist, and developers can and should use both function-scope and block-scope techniques where respectively appropriate to produce better, more readable/maintainable code."


Closures 

Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.

function foo() {
    var a = 2;

    function baz() {
        console.log( a ); // 2
    }

    bar( baz );
}

function bar(fn) {
    fn(); // look ma, I saw closure!
}

In the above code, there are two functions with separate lexical scopes.  foo() and bar(fn) both have their own scope.  bar(fn) is able to invoke the baz() function outside of the original foo() lexical scope.  bar(fn) takes the argument "baz," and executes it as baz(), which is already a function declared inside of foo().

------------------------ Modules ---------------------------

Modules require two key characteristics: 

1) an outer wrapping function being invoked, to create the enclosing scope 

2) the return value of the wrapping function must include reference to at least one inner function that then has closure over the private inner scope of the wrapper.


MODULE EX: 

var foo = (function CoolModule(id) {
    function change() {
        // modifying the public API
        publicAPI.identify = identify2;
    }

    function identify1() {
        console.log( id );
    }

    function identify2() {
        console.log( id.toUpperCase() );
    }

    var publicAPI = {
        change: change,
        identify: identify1
    };

    return publicAPI;
})( "foo module" );

A self invoking function "foo" creates a module in which you can use "foo" to call the various functions within the self-invoking function.  

For example: 

foo.identify(); // runs the indentify1 function, which will print out the id "foo module"  

foo.change(); // runs the change function, which will switch the key:value pair of identify: identify1 --> identify: identify2.

foo.identify(); // FOO MODULE  // after calling the change() function, you can now use foo.identify() to print out the capitalized version "FOO MODULE".




